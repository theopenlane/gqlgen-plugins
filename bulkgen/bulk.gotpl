{{ reserveImport "context"  }}
{{ reserveImport "sync" }}
{{ reserveImport "github.com/theopenlane/core/pkg/logx" }}
{{ reserveImport "github.com/theopenlane/utils/rout" }}

{{- if $.EntImport }}
{{ reserveImport $.EntImport }}
{{- end }}

{{- if $.ModelImport }}
{{ reserveImport $.ModelImport }}
{{- end }}

{{- if $.GraphQLImport }}
{{ reserveImport $.GraphQLImport }}
{{- end }}

{{- if $.CSVGeneratedImport }}
{{ reserveImport $.CSVGeneratedImport }}
{{- end }}

{{ $root := . }}

{{ range $object := .Objects }}

{{- if eq $object.OperationType "create" }}
// bulkCreate{{ $object.Name }} uses the CreateBulk function to create multiple {{ $object.Name }} entities
func (r *mutationResolver) bulkCreate{{ $object.Name }} (ctx context.Context, input []*generated.Create{{ $object.Name }}Input) (*{{ $root.ModelPackage }}{{ $object.Name }}BulkCreatePayload, error) {
    c := withTransactionalMutation(ctx)
	builders := make([]*generated.{{ $object.Name }}Create, len(input))
	for i, data := range input {
		builders[i] = c.{{ $object.Name }}.Create().SetInput(*data)
	}

	res, err := c.{{ $object.Name }}.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "{{ $object.Name | toLower }}"})
	}

	// return response
	return &{{ $root.ModelPackage }}{{ $object.Name }}BulkCreatePayload{
		{{ $object.PluralName }}: res,
	}, nil
}
{{- else if eq $object.OperationType "update" }}
// bulkUpdate{{ $object.Name }} updates multiple {{ $object.Name }} entities
func (r *mutationResolver) bulkUpdate{{ $object.Name }} (ctx context.Context, ids []string, input generated.Update{{ $object.Name }}Input) (*{{ $root.ModelPackage }}{{ $object.Name }}BulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.{{ $object.Name }}, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each {{ $object.Name | toLower }} individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			logx.FromContext(ctx).Error().Msg("empty id in bulk update for {{ $object.Name | toLower }}")
			continue
		}

		// get the existing entity first
		existing, err := c.{{ $object.Name }}.Get(ctx, id)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("{{ $object.Name | toLower }}_id", id).Msg("failed to get {{ $object.Name | toLower }} in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input){{- range $appendField := $object.AppendFields }}.{{ $appendField }}(input.{{ $appendField }}){{- end }}.Save(ctx)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("{{ $object.Name | toLower }}_id", id).Msg("failed to update {{ $object.Name | toLower }} in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &{{ $root.ModelPackage }}{{ $object.Name }}BulkUpdatePayload{
		{{ $object.PluralName }}: results,
		UpdatedIDs: updatedIDs,
	}, nil
}
{{- if and $object.HasCSVUpdateMutation $root.CSVGeneratedImport }}

// bulkUpdateCSV{{ $object.Name }} updates multiple {{ $object.Name }} entities from CSV data with per-row values
func (r *mutationResolver) bulkUpdateCSV{{ $object.Name }} (ctx context.Context, inputs []*csvgenerated.{{ $object.Name }}CSVUpdateInput) (*{{ $root.ModelPackage }}{{ $object.Name }}BulkUpdatePayload, error) {
	if len(inputs) == 0 {
		return nil, rout.NewMissingRequiredFieldError("input")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.{{ $object.Name }}, 0, len(inputs))
	updatedIDs := make([]string, 0, len(inputs))

	// update each {{ $object.Name | toLower }} individually with its own input values
	for _, input := range inputs {
		if input == nil || input.ID == "" {
			logx.FromContext(ctx).Error().Msg("empty id in CSV bulk update for {{ $object.Name | toLower }}")
			continue
		}

		// get the existing entity first
		existing, err := c.{{ $object.Name }}.Get(ctx, input.ID)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("{{ $object.Name | toLower }}_id", input.ID).Msg("failed to get {{ $object.Name | toLower }} in CSV bulk update operation")
			continue
		}

		// setup update request with this row's input values
		updatedEntity, err := existing.Update().SetInput(input.Input){{- range $appendField := $object.AppendFields }}.{{ $appendField }}(input.Input.{{ $appendField }}){{- end }}.Save(ctx)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("{{ $object.Name | toLower }}_id", input.ID).Msg("failed to update {{ $object.Name | toLower }} in CSV bulk operation")
			return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "{{ $object.Name | toLower }}"})
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, input.ID)
	}

	return &{{ $root.ModelPackage }}{{ $object.Name }}BulkUpdatePayload{
		{{ $object.PluralName }}: results,
		UpdatedIDs: updatedIDs,
	}, nil
}
{{- end }}
{{- else if eq $object.OperationType "delete" }}
// bulkDelete{{ $object.Name }} deletes multiple {{ $object.Name }} entities by their IDs
func (r *mutationResolver) bulkDelete{{ $object.Name }} (ctx context.Context, ids []string) (*{{ $root.ModelPackage }}{{ $object.Name }}BulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// use r.db in context so interceptors use the connection pool instead of the shared transaction
			poolCtx := generated.NewContext(ctx, r.db)

			// delete each {{ $object.Name | toLower }} individually to ensure proper cleanup
			if err := r.db.{{ $object.Name }}.DeleteOneID(id).Exec(poolCtx); err != nil {
				logx.FromContext(poolCtx).Error().Err(err).Str("{{ $object.Name | toLower }}_id", id).Msg("failed to delete {{ $object.Name | toLower }} in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.{{ $object.Name }}EdgeCleanup(poolCtx, id); err != nil {
				logx.FromContext(poolCtx).Error().Err(err).Str("{{ $object.Name | toLower }}_id", id).Msg("failed to cleanup {{ $object.Name | toLower }} edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some {{ $object.Name | toLower }} deletions failed")
	}

	return &{{ $root.ModelPackage }}{{ $object.Name }}BulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}
{{- end }}

{{ end }}
